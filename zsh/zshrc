if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

export PATH=~/.config/composer/vendor/bin:$PATH
export PATH=~/.composer/vendor/bin:$PATH
export ZSH="$HOME/.oh-my-zsh"

ZSH_THEME="robbyrussell"
zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to disable auto-setting terminal title.
DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
ENABLE_CORRECTION="false"

COMPLETION_WAITING_DOTS="true"

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(
    git
    local
)

source $ZSH/oh-my-zsh.sh

# User configuration

#source ~/powerlevel10k/powerlevel10k.zsh-theme

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

alias zshconfig="vim ~/.zshrc"
alias zsource="source ~/.zshrc"
alias ohmyzsh="vim ~/.oh-my-zsh"
alias tmuxconfig="vim ~/.tmux.conf"
alias gdiff="git diff master..$(git_current_branch) | grep \"^diff.*php$\""
alias selector="((which rofi>/dev/null && (rofi -show -dmenu -i || true))||(which fzf >/dev/null && fzf))"
alias git-recent-branches="git reflog show --pretty=format:'%gs ~ %gd' --date=relative | grep \"checkout:\" | grep -oE '[^ ]+ ~ .*' | awk -F~ '!seen[\$1]++' | head -n 15 | sed -n -e \"s/~ HEAD@{/   # /p\" | sed -n -e \"s/}//p\""
alias git-checkout-recent="git co \`git-recent-branches|selector|sed -n -e \"s/#.*$//p\"\`"
alias nah="git reset --hard && git clean -df"
alias web2local="~/./ngrok http 8000"
alias ll='tail -f -n100 storage/logs/`ls -t storage/logs/ | head -1`'
alias artisan="php artisan"
alias a="nocorrect php artisan"
alias byebatch="php artisan queue:prune-batches --unfinished=1"
alias publish="curl -F file=@- https://publish.ip1.cc"
alias dotfiles="cd ~/dotfiles"
alias pubkey="cat ~/.ssh/id_rsa.pub"
alias ci="composer install"
alias zshlocal="vi ~/.oh-my-zsh/custom/plugins/local/local.plugin.zsh"

# test <filename>
function  watchdox {
	phpunit-watcher watch --filter=$1 --testdox
}

function watch {
	phpunit-watcher watch --filter=$1
}

function test {
	php artisan test --parallel
}

function artisan: {
	php artisan | grep $1
}

function addalias {
        echo "alias $1" >> ~/.zshrc
}

function newbranch {
	git checkout master
	git checkout -b SKU-$1
}

tlog() {
    log_directory="storage/logs"
    log_name="${1:-laravel}"
    log_filename="${log_name}-$(date +'%Y-%m-%d').log"
    log_file="${log_directory}/${log_filename}"
    
    num_lines="${2:-50}"  # Default to tailing 10 lines if no value is provided
    
    tail -n "${num_lines}" -f "${log_file}"
}

function www() {
    # List directories in /var/www
    directories=$(find /var/www -maxdepth 1 -type d)

    # Use fzf for interactive selection
    selected_directory=$(echo "$directories" | fzf --prompt="Select a directory: ")

    # Change to the selected directory
    if [ -n "$selected_directory" ]; then
        cd "$selected_directory" || return
        echo "You are now in: $selected_directory"
    else
        echo "No directory selected"
    fi
}

function add_ssh_user() {
    if [[ -z "$1" || -z "$2" ]]; then
        echo "Usage: add_ssh_user <username> <ssh-public-key>"
        return 1
    fi

    local username="$1"
    shift  # Shift to access all remaining arguments as the SSH key
    local ssh_key="$@"

    # Create the new user with a home directory, zsh shell, and "users" as the main group
    sudo useradd -m -s /usr/bin/zsh -g users "$username"

    # Set the account to be passwordless
    sudo passwd -d "$username"

    # Create the .ssh directory and set permissions
    sudo mkdir -p /home/"$username"/.ssh
    sudo chmod 700 /home/"$username"/.ssh

    # Add the provided SSH key to authorized_keys
    echo "$ssh_key" | sudo tee /home/"$username"/.ssh/authorized_keys > /dev/null
    sudo chmod 600 /home/"$username"/.ssh/authorized_keys

    # Adjust ownership of the home and .ssh directories
    sudo chown -R "$username":users /home/"$username"/.ssh

    echo "Restarting ssh service"
    sudo systemctl restart ssh

    echo "User $username has been created and configured for passwordless SSH access with 'users' as the main group."
}

export HIST_STAMPS="yyyy-mm-dd"

# Generic aliases useful across machines
alias pip=pip3
alias pclaude="claude --dangerously-skip-permissions"

# Git stash aliases - save and restore with interactive selection
gsave() {
    if [ -z "$1" ]; then
        echo -n "Enter stash description: "
        read description
        if [ -z "$description" ]; then
            echo "No description provided. Cancelled."
            return 1
        fi
        git stash push -u -m "$description"
    else
        git stash push -u -m "$*"
    fi
}

# Interactive git stash restore with fzf
grestore() {
    # Check if there are any stashes
    if ! git stash list >/dev/null 2>&1 || [ -z "$(git stash list)" ]; then
        echo "No stashes found."
        return 1
    fi

    # Use fzf to select a stash interactively with diff preview
    local stash_selection=$(git stash list --format="%gd: %gs" | \
        fzf --height=60% --border \
            --prompt="Select stash to restore: " \
            --preview="git stash show -p \$(echo {} | cut -d: -f1)" \
            --preview-window=right:60%:wrap)

    if [ -z "$stash_selection" ]; then
        echo "No stash selected."
        return 1
    fi

    # Extract stash reference (e.g., stash@{0})
    local stash_ref=$(echo "$stash_selection" | cut -d: -f1)

    echo "Selected: $stash_selection"
    echo

    # Ask user whether to pop (delete) or apply (keep)
    echo "How would you like to restore this stash?"
    echo "1) Pop (restore and delete stash)"
    echo "2) Apply (restore but keep stash)"
    echo -n "Choice [1/2]: "
    read choice

    case $choice in
        1|"")
            echo "Popping stash $stash_ref..."
            git stash pop "$stash_ref"
            ;;
        2)
            echo "Applying stash $stash_ref..."
            git stash apply "$stash_ref"
            ;;
        *)
            echo "Invalid choice. Cancelled."
            return 1
            ;;
    esac
}
work() { "$(git rev-parse --show-toplevel)/utils/worktree" "$@"; }
